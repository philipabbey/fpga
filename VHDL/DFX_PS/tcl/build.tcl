####################################################################################
#
#  Distributed under MIT Licence
#    See https://github.com/philipabbey/fpga/blob/main/LICENCE.
#
####################################################################################
#
# Build script for static plus 4 reconfigurable partitions.
#
# P A Abbey, 12 February 2025
#
####################################################################################
#
# source -notrace {<path>/DFX_PS/tcl/build.tcl}

set vivado_install {C:\Xilinx\Vivado\2023.2}
# Sometimes we want to paste the commands into Vivado outside the script.
if {[info script] == ""} {
  set prod_dir {Drive:/Path/.../VHDL/DFX_PS/products}
  set script "build.tcl"
} else {
  set prod_dir [file dirname [file dirname [file normalize [info script]]]]/products
  set script [file tail [file normalize [info script]]]
}
# One of the 'reconfig_action' architectures 'by_value' uses XPM ROM so that BIT code
# can be inserted after place & route by 'updatemem'.
#set xpm_rom 1
set first_rm 0
set subsequent_rms [list 1 2 3 4]
# Needs to match the VHDL code in 'reconfig_action'.
# Number of 32-bit words in ROM
set rom_addr_bits 12

# Delete all previous products
set fs [glob -nocomplain $prod_dir/*]
if {[llength $fs] > 0} {
  file delete -force {*}$fs
}

source -notrace [get_property REPOSITORY \
  [get_ipdefs *dfx_controller:1.0]]/xilinx/dfx_controller_v1_0/tcl/api.tcl

# Memory layout is specified by 'dscr', so extract it from the provided netlist for the IP core
#
proc multiple_bin2mem {dscr outfile args} {
  upvar rom_addr_bits rom_addr_bits
  set proc_name [lindex [info level 0] 0]
  set rm 0
  set addr 0
  set fo [open $outfile w]
  puts "dscr = $dscr"
  puts $fo "// Generated by TCL '$proc_name' in script '[file normalize [info script]]'."
  puts $fo "// MEM file created from:"
  foreach infile $args {
    puts "dfx_controller_v1_0::netlist::get_rm_bs_address dscr VS_0 RM_${rm}"
    set start [dfx_controller_v1_0::netlist::get_rm_bs_address dscr VS_0 RM_${rm}]
    puts $fo "//  * '$infile', start address [format "0x%08X" $start] ($start), size [file size $infile] bytes."
    incr rm
  }

  set rm 0
  foreach infile $args {
    # DFX Controller address should be in bytes
    set start [dfx_controller_v1_0::netlist::get_rm_bs_address dscr VS_0 RM_${rm}]
    # DFX Controller size is definitely in bytes
    set size [dfx_controller_v1_0::netlist::get_rm_bs_size dscr VS_0 RM_${rm}]
    if {[file size $infile] > $size} {
      puts "WARNING: \[$proc_name\] Allocated space not large enough for the MEM file contents ([file size $infile] > $size). Change the IP settings for RM${rm}."
    } elseif {$size == 0} {
      puts "WARNING: \[$proc_name\] IP configuration error for RM${rm}, change the IP settings."
    } else {
      if {[file size $infile] != $size} {
        puts "INFO: \[$proc_name\] DFX RM${rm} file $infile, size is $size bytes, should be [file size $infile] bytes"
      }
      # DFX Controller address should be in bytes, we want addresses of 32-bit words.
      set start [expr $start / 4]
      # DFX Controller size is definitely in bytes, we want addresses of 32-bit words.
      set size [expr $size / 4]
      # Not including this last address, i.e.  up to ($end-1)
      set end [expr $start + $size]
      puts "INFO: \[$proc_name\] - DFX RM${rm} file $infile, start $start, end $end, size $size (32-bit words)"
      # Pad up to the start address
      for {set i $addr} {$i < $start} {incr i} {
        puts $fo [format "@%08X FFFFFFFF" $i]
      }
      set fi [open $infile r]
      fconfigure $fi -translation binary
      while {($addr < [expr {2 ** $rom_addr_bits}]) && ($addr < $end)} {
        if {$addr >= $start && $addr < $end && ![eof $fi]} {
          # Inside ROM space with data to read
          set word [read $fi 4]
          binary scan $word Iu1 w
          puts $fo [format "@%08X %08X" $addr $w]
        } else {
          # Outside ROM space, e.g. after '$end'
          puts $fo [format "@%08X FFFFFFFF" $addr]
        }
        incr addr
      }
      if {($addr >= 2 ** $rom_addr_bits) && ![eof $fi]} {
        puts "ERROR: \[$proc_name\] - ROM address space insufficient."
      }
      close $fi
    }
    incr rm
    for {set i $addr} {$i < [expr {2 ** $rom_addr_bits}]} {incr i} {
      puts $fo [format "@%08X FFFFFFFF" $i]
    }
  }
  close $fo
}

# I prefer to close all open designs at the start before they show out of date
foreach d [get_designs -quiet] {
  current_design $d
  close_design -quiet
}

set_property top {ps_pl_wrapper} [current_fileset]
puts "INFO: \[$script\] Build RM $first_rm"
# There should be only one Block Design
current_project {dfx_ps_legacy}

set block_diag [get_files -filter {FILE_TYPE == "Block Designs"}]
set proj_dir [get_property DIRECTORY [get_projects dfx_ps_legacy]]
set proj_stem ${proj_dir}/[lindex [file split [get_property DIRECTORY [get_projects dfx_ps_legacy]]] end]

# Need to manage hang-over DCP files. Just remove them?
remove_files -quiet -fileset utils_1 ${proj_stem}.srcs/utils_1/imports/synth_1/ps_pl_wrapper.dcp
if {[file exists ${proj_stem}.srcs/utils_1/imports/synth_1/ps_pl_wrapper.dcp]} {
  file delete -force ${proj_stem}.srcs/utils_1/imports/synth_1/ps_pl_wrapper.dcp
}

open_bd_design $block_diag
set_property CONFIG.rm_num_g $first_rm [get_bd_cells {vhdl_conv_i}]
save_bd_design
close_bd_design [get_bd_designs ps_pl]

generate_target all $block_diag
catch {
  config_ip_cache -export [get_ips -all ps_pl_proc_sys_reset_0_0]
}
export_ip_user_files \
  -of_objects $block_diag \
  -no_script \
  -sync \
  -force \
  -quiet

create_ip_run $block_diag
set vhdl_run [get_runs ps_pl_vhdl*_synth*]
reset_run   $vhdl_run
launch_runs $vhdl_run -jobs 14
wait_on_run $vhdl_run

open_run [get_runs $vhdl_run]
write_checkpoint -force -cell {U0/wrapper_i/reconfig_rp} "$prod_dir/synth_rm${first_rm}.dcp"
close_design

reset_run synth_1
launch_runs impl_1 -jobs 14
wait_on_run impl_1
open_run impl_1
# https://docs.amd.com/v/u/en-US/pg374-dfx-controller
set_property BITSTREAM.GENERAL.COMPRESS          false [get_designs impl_1]
set_property STEPS.WRITE_BITSTREAM.ARGS.BIN_FILE true  [get_runs impl_1]

# RM${first_rm} only
set crp [get_cells {ps_pl_i/vhdl_conv_i/U0/wrapper_i/reconfig_rp}]
write_bitstream \
  -cell $crp \
  -raw_bitfile \
  -bin_file \
  -force \
  "$prod_dir/rm${first_rm}.bit"

write_hw_platform \
  -fixed \
  -force \
  -file ${proj_dir}/dfx_ps_legacy.xsa

# Use the compression library provided by the DFX Controller IP
dfx_controller_v1_0::format_bin_for_icap \
  -i "$prod_dir/rm${first_rm}.bin" \
  -o "$prod_dir/rm${first_rm}_comp.bin" \
  -c 1

update_design -cell $crp -black_box
lock_design -level routing
write_mem_info \
  -force_detect_xpm \
  -force \
  "$prod_dir/roms.mmi"
write_checkpoint -force "$prod_dir/static.dcp"

# Sequence of RMs
foreach rm $subsequent_rms {
  puts "INFO: \[$script\] Build RM ${rm}"
  # There should be only one Block Design
  current_project {dfx_ps_legacy}
  remove_files -quiet -fileset utils_1 ${proj_stem}.srcs/utils_1/imports/synth_1/ps_pl_wrapper.dcp
  if {[file exists ${proj_stem}.srcs/utils_1/imports/synth_1/ps_pl_wrapper.dcp]} {
    file delete -force ${proj_stem}.srcs/utils_1/imports/synth_1/ps_pl_wrapper.dcp
  }
  open_bd_design $block_diag
  set_property CONFIG.rm_num_g $rm [get_bd_cells {vhdl_conv_i}]
  save_bd_design
  close_bd_design [get_bd_designs ps_pl]

  generate_target all $block_diag
  catch {
    config_ip_cache -export [get_ips -all ps_pl_proc_sys_reset_0_0]
  }
  export_ip_user_files \
    -of_objects $block_diag \
    -no_script \
    -sync \
    -force \
    -quiet

  create_ip_run $block_diag
  reset_run   $vhdl_run
  launch_runs $vhdl_run -jobs 14
  wait_on_run $vhdl_run

  open_run [get_runs $vhdl_run]
  write_checkpoint -force -cell {U0/wrapper_i/reconfig_rp} "$prod_dir/synth_rm${rm}.dcp"
  close_design

  # Create a new Vivado instance briefly for RM
  create_project -part xc7z010clg400-1 -in_memory "Stitch RM${rm}"
  add_files "$prod_dir/static.dcp"
  add_files "$prod_dir/synth_rm${rm}.dcp"
  set_property SCOPED_TO_CELLS $crp [get_files "$prod_dir/synth_rm${rm}.dcp"]
  # Project or non-project modes
  link_design -top {ps_pl_wrapper} -part xc7z010clg400-1 -reconfig_partitions {ps_pl_i/vhdl_conv_i/U0/wrapper_i/reconfig_rp}
  opt_design
  place_design
  route_design
  write_bitstream \
    -cell $crp \
    -raw_bitfile \
    -bin_file \
    -force \
    "$prod_dir/rm${rm}.bit"
  close_project
  # Use the compression library provided by the DFX Controller IP
  dfx_controller_v1_0::format_bin_for_icap \
    -i "$prod_dir/rm${rm}.bin" \
    -o "$prod_dir/rm${rm}_comp.bin" \
    -c 1
}

puts "INFO: \[$script\] Amending DFX Controller IP memory parameters in the netlist."
set dfx_ip [get_ips dfx_controller]
if {$dfx_ip eq ""} {
  error "ERROR: \[$script\] DFX IP not found."
}
set config [get_property CONFIG.ALL_PARAMS $dfx_ip]
if {$config eq ""} {
  error "ERROR: \[$script\] DFX configuration not found."
}
set dscr [dfx_controller_v1_0::netlist::get_descriptor $config {ps_pl_i/vhdl_conv_i/U0/wrapper_i/reconfig_action_i/dfx_controller_i/U0}]
if {$dscr eq ""} {
  error "ERROR: \[$script\] DFX descriptor not found."
}
# Address offsets in bytes, we have 2 ** 'rom_addr_bits+2' bytes available
dfx_controller_v1_0::netlist::set_rm_bs_address dscr VS_0 RM_0 [format "0x%08X"     0]
dfx_controller_v1_0::netlist::set_rm_bs_address dscr VS_0 RM_1 [format "0x%08X"  4096]
dfx_controller_v1_0::netlist::set_rm_bs_address dscr VS_0 RM_2 [format "0x%08X"  8192]
dfx_controller_v1_0::netlist::set_rm_bs_address dscr VS_0 RM_3 [format "0x%08X" 12288]
set mem_file_list {}
set ip_rm 0
# rm*_comp.bin should all have been created by now
foreach rm $subsequent_rms {
  set rm_file "$prod_dir/rm${rm}_comp.bin"
  if {[file exists $rm_file]} {
    dfx_controller_v1_0::netlist::set_rm_bs_size dscr VS_0 RM_${ip_rm} [file size $rm_file]
    puts "INFO: \[$script\] RM${ip_rm}, file '${rm_file}' size set to [file size $rm_file]"
    lappend mem_file_list $rm_file
    incr ip_rm
    puts "ip_rm = ${ip_rm}"
  } else {
    puts "ERROR: \[$script\] File '${rm_file}' not found."
  }
}
dfx_controller_v1_0::netlist::apply_descriptor dscr

# After implementation
# https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/write_bitstream
# Static only as RMs have been black boxed
write_bitstream \
  -no_partial_bitfile \
  -force \
  "$prod_dir/static.bit"
write_checkpoint -force "$prod_dir/static_dfx.dcp"
close_design

# Now go back to the first image in order to create an initial image with the correct DFX Controller parameters
create_project -part xc7z010clg400-1 -in_memory "Stitch RM${first_rm}"
add_files "$prod_dir/static_dfx.dcp"
add_files "$prod_dir/synth_rm${first_rm}.dcp"
set_property SCOPED_TO_CELLS $crp [get_files "$prod_dir/synth_rm${first_rm}.dcp"]
# Project or non-project modes
link_design -top {ps_pl_wrapper} -part xc7z010clg400-1 -reconfig_partitions {ps_pl_i/vhdl_conv_i/U0/wrapper_i/reconfig_rp}
opt_design
place_design
route_design
write_bitstream \
  -raw_bitfile \
  -bin_file \
  -force \
  "$prod_dir/initial.bit"
close_project


current_project {dfx_ps_legacy}
if {[llength $mem_file_list] == 4} {
  puts "INFO: \[$script\] Substituting initial ROM contents."
  multiple_bin2mem $dscr "$prod_dir/rm_all_comp.mem" {*}$mem_file_list

  # https://docs.amd.com/r/2023.2-English/ug1580-updatemem/
  #
  # updatemem -h
  # ECHO is off.
  # ECHO is off.
  #
  # Usage: updatemem [options]
  # (Switches with double dash '--' can also be used with a single dash '-')
  #
  # Help message:
  #
  #   -h [ --help ]          Display help
  #   --meminfo arg          Input meminfo file with extension '.mmi' or .smi (for
  #                          generating .mem files). The .mmi file can be generated
  #                          using the write_mem_info TCL command in Vivado. The
  #                          Tcl generate_mem_files will generate the .smi file.
  #   --data arg             Input elf or mem file to be used to populate the
  #                          BRAMs. When writing .mem files for simulation this
  #                          command line argument will only accept elf input file
  #                          type.
  #   --bit arg              Input bit or rcdo file
  #   --proc arg             Instance path of the processor in the design
  #   --out arg              Output bit or rcdo file
  #   --force [=arg(=1)]     Overwrite existing output bit file
  #
  # Examples:
  #   updatemem -meminfo top.mmi -data top.elf -bit top.bit -proc system_i/microblaze -out top_out.bit
  #   updatemem -meminfo top.mmi -data top.mem -bit top.bit -proc system_i/microblaze -out top_out.bit
  #   updatemem -meminfo top.mmi -data top.elf -bit top.bit -proc system_i/microblaze -out top_out.bit -force
  #   updatemem -meminfo top.mmi -data top.elf -bit top.rcdo -proc system_i/microblaze -out top_out.rcdo
  #   updatemem -meminfo top.mmi -data top.mem -bit top.rcdo -proc system_i/microblaze -out top_out.rcdo
  # Write out the translated elf file as a .mem file(s) for third party simulators.
  #   updatemem -meminfo top.smi -data top.elf -proc system_i/microblaze
  
  # Stuff the ROM contents in only once we have a bitstream
  exec "[file normalize $vivado_install]/bin/updatemem.bat" \
    -force \
    -meminfo "$prod_dir/roms.mmi" \
    -data    "$prod_dir/rm_all_comp.mem" \
    -bit     "$prod_dir/initial.bit" \
    -proc    "ps_pl_i/vhdl_conv_i/U0/wrapper_i/reconfig_action_i/rom_i/xpm_memory_base_inst" \
    -out     "$prod_dir/initial_rom.bit"
}
